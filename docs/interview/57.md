### 1 display:none 和 visbility:hidden的区别
* 1.display:none是彻底消失，不在文档流中占位，浏览器也不会解析该元素；visibility:hidden是视觉消失了，可以理解为透明度为0的效果，在文档流中占位，浏览器会解析该元素；  
* 2.使用visibility:hidden比display:none性能上要好，display:none切换显示时visibility，页面产生回流（当页面中的一部分元素需要改变规模尺寸、布局、显示隐藏等，页面重新构建，此时就是回流。所有页 面第一次加载时需要产生一次回流），而visibility切换是否显示时则不会引起回流。  
  
### 2 link和@import的区别 
* 区别1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。
* 区别2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。
* 区别3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。
* 区别4：link支持使用Javascript控制DOM去改变样式；而@import不支持。
  
* Link:XHTML标签；除了可以加载CSS外，还可以定义RSS，定义rel的链接属性；当页面被加载的时候，link使用的CSS会同时被加载，故浏览者浏览的时候，会有样式； 
* @import:是css提供的一种方式；只有当所有的界面都被下载完才会加载，所以用这个的时候，有的时候开始会没有样式； 老的浏览器不会支持只有在IE5以上才会支持。使用dom不可以控制@import
--------------------- 

### 3 进程和线程的区别
* 进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。
* 线程：是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。
* 一个程序至少一个进程，一个进程至少一个线程。
  
### 4 null 和undefined的区别
* 在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。   null值则是表示空对象指针。
* null是javascript的关键字，可以认为是对象类型，它是一个空对象指针，和其它语言一样都是代表“空值”，不过 undefined 却是javascript才有的。undefined是在ECMAScript第三版引入的，为了区分空指针对象和未初始化的变量，它是一个预定义的全局变量。没有返回值的函数返回为undefined，没有实参的形参也是undefined。

### 5 document.write和innerHTML
* document.write是直接将内容写入页面的内容流，会导致页面全部重绘，
* innerHTML将内容写入某个DOM节点，不会导致页面全部重绘

### 6 前后端分离怎么理解，怎么优化前端代码来提高项目执行速度
* 前端负责浏览器端（客户端）用户交互界面和逻辑等，显示数据；后端负责数据的处理和存储等，提供数据。
* 优势 提高工作效率  分工更加明确   局部性能提升  降低维护成本

### 7 babel/es6中箭头函数和function的区别
* 普通函数中的this指向函数被调用的对象，因此对于不同的调用者，this的值是不同的。而箭头函数中并没有自己的this（同时，箭头函数中也没有其他的局部变量，如this，argument，super等），所以箭头函数中的this是固定的，它指向定义该函数时所在的对象。

* 普通函数的this总是指向它的直接调用者。在严格模式下，没找到直接调用者，则函数中的this是undefined。在默认模式下（非严格模式），没找到直接调用者，则函数中的this指向window。

* 箭头函数相当于匿名函数，不能使用New作为构造函数来使用箭头函数中的this始终指向其父级作用域中的this。换句话说，箭头函数会捕获其所在的上下文的this值，作为自己的this值。任何方法都改变不了其指向

### 8 XML和JSON的区别
 * 数据体积方面。json的数据体积小，传递速度更快
 * 数据交互方面。json和Js交互更方便，更容易解析

### 9 主流浏览器内核私有属性css前缀
 * mozilla内核 (firefox,flock等)     -moz  
   webkit内核(safari,chrome等)   -webkit  
   opera内核(opera浏览器)         -o  
   trident内核(ie浏览器)               -ms

### 10 get和post的区别，何时使用Post
  *  GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符  
     POST：一般用于修改服务器上的资源，对所发送的信息没有限制。  
     GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，  
     也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
  
  *  然而，在以下情况中，请使用 POST 请求：  
     无法使用缓存文件（更新服务器上的文件或数据库）  
     向服务器发送大量数据（POST 没有数据量限制）  
     发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 

### 11 性能优化的方法
### 12 Ajax 和json是什么，优缺点
  * Ajax是异步JavaScript和XML，用于在Web页面中实现异步数据交互。 
    
    优点：  
    可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量  
    避免用户不断刷新或者跳转页面，提高用户体验  

    缺点：  
    对搜索引擎不友好  
    要实现Ajax下的前后退功能成本较大  
    可能造成请求数的增加  
    跨域问题限制  

  * JSON是一种轻量级的数据交换格式，ECMA的一个子集   
    JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。  
    优点：  
    轻量级、易于人的阅读和编写，便于机器（JavaScript）解析，支持复合数据类型（数组、对象、字符串、数字）

### 13 $(document).ready 和 window.onload的区别
    JavaScript的入口函数要等到DOM创建完毕，页面中所有资源（包括图片、文件）加载完成才开始执行。
    jQuery的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。
    window.onload只能注册一次，jQuery入口函数可以注册多次
    jQuery的入口函数，封装了DOM中的DOMContentLoaded事件（此事件DOM加载完毕之后就执行）

### 14 微信小程序的优劣势
微信小程序的优势

　　1、对用户使用上来说，确实方便，要用的时候打开，不用的时候关掉，即用即走。这点比需要下载，还要占用手机内存空间的APP要好。  
　　2、主要的样式代码都封装在微信小程序里面，所以打开速度比普通的H5要快，接近原生APP。  
　　3、可以调用比H5更多的手机系统功能来进行开发，例如GPS定位、录音、拍视频、重力感应等，能开发更丰富的使用场景。  
　　4、在安卓手机上可以添加到手机桌面，看上去跟原生APP差不多，但仅限安卓手机，iphone就不行了。  
　　5、运行速度跟APP差不多，也能做出很多H5不做到的功能，开发成本跟H5差不多，相对来说开发成本比APP要低。

微信小程序的缺点

　　1、微信小程序只有1M的大小，这样导致无法开发大型一些的小程序。所以目前你会看到很多小程序真的很小很简单。  
　　2、小程序的技术框架还不稳定，开发方法时常有修改，导致短时间内经常要升级维护，或许这能解析为什么小程序只能1M大小，怕部署太大型的项目会出大问题。  
　　3、不能跳转外链网址，所以间接影响了小程序的开放性。也可能是想限制其他支付方式或功能接入(或许是我想多了)。  
　　4、不能直接分享到朋友圈，哎呀，少了一个重要的推广方式。  
　　5、需要像APP一样审核上架，这点比HTML5即做即发布要麻烦些。

### 15 async和await来处理异步
用async和await发送异步请求，从服务端的获取数据  
async->放在函数的前面，表示函数是一个异步函数，表示该函数执行不会阻塞后面代码执行。async返回一个promise对象，如果要获取到Promise的返回值，用then方法  
await 后面放置返回promise对象的表达式

```js
function takeLongTime() {
    return new Promise(resolve => {
        setTimeout(() => resolve("long_time_value"), 1000);
    });
}

async function test() {
    const v = await takeLongTime();
    console.log(v);
}

test();
```

### 16  回调函数 

```js
 function callback() {
   console.log(1)
 }
 SetTimeout(callback,2000)
 //callback返回一个函数对象，传递给settimeout的仍是一个函数对象
```
 * 一个函数作为参数传递给另一个函数，当某个事件发生后，触法回调函数执行
 * 回调函数使用场景：在函数外部获取到函数内部中异步操作结果
 * 用法：在异步操作中有结果时，把结果以函数实参方式进行传递
 * 由于回调函数是异步，在代码中每一层回调函数都会依赖上一层回调函数执行完形成了层层嵌套的关系--回调地狱

 ### 17 cookie是什么？cookie有哪些特性？cookie和session有什么区别
cookie 和session 的区别：

1、cookie数据存放在客户的浏览器上，session数据放在服务器上。

2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
   考虑到安全应当使用session。

3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
   考虑到减轻服务器性能方面，应当使用COOKIE。

4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

5、所以个人建议：
   将登陆信息等重要信息存放为SESSION
   其他信息如果需要保留，可以放在COOKIE中

### 18 写一个简单的渐变色效果
CSS3 定义了两种类型的渐变（gradients）：

    线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向

    径向渐变（Radial Gradients）- 由它们的中心定义

语法：

    background: linear-gradient(direction, color-stop1, color-stop2, ...);

```css
background-image:linear-gradient(
    to right,
    pink 40%,
    pink 40%,
    orange 40%,
    orange 80%,
    yellow 20% 
  )

      
#grad {
  /* Safari 5.1 - 6.0 */
  background: -webkit-repeating-radial-gradient(red, yellow 10%, green 15%);
  /* Opera 11.6 - 12.0 */
  background: -o-repeating-radial-gradient(red, yellow 10%, green 15%);
  /* Firefox 3.6 - 15 */
  background: -moz-repeating-radial-gradient(red, yellow 10%, green 15%);
  /* 标准的语法 */
  background: repeating-radial-gradient(red, yellow 10%, green 15%);
}
```
### 19 如何对网站的文件和资源进行优化
1、图片优化  
首先，你需要优化你网站上的图片，来获得丝毫加速网站的机会。从原图上移除额外的注解、不必要的空间和无用的颜色，将图片保存为JPEG格式，因为它即使占用空间小，也能保证图片的高质量。  
对于WordPress网站，建议使用smush.it插件来自动优化网站的图片。如果图片是PNG格式，可以使用tinypng 优化图片，提高图片质量。

2、开启GZip压缩  
GZip压缩听起来很复杂，但实际上很简单，被用于减少HTTP请求的大小来缩短响应时间。因为这允许你发送GZip压缩文件而不是HTML文件给浏览器，它将缩短页面等待时间和加载时间。对于Apache服务器，可以将下面的代码添加到.htaccess文件中来开启GZip压缩。

3、服务器响应时间  
即使网站已经格外优化，但是除非服务器响应时间非常快，否则就不会有什么大的效果。当涉及到提高网站的速度，服务器响应时间起着重要的作用。下面是一些提高服务器响应时间的建议。  
有独立的服务器，而不是选择共享/托管服务器。  
提高Web服务器的质量。  
移除不必要的插件，只有那些必要的插件，才需要一直保持启用状态。

4、使用CDN  
内容分发网络(CDN)是位于不同地理位置的服务器组成的网络。每个服务器都拥有所有网站的文件副本。当用户请求文件和网页时，就可以直接从就近的网站服务器获取相应资源(也可以是从负载最小的服务器)。你可以使用Amazon cloud front 或者MaxCDN为网站开启CDN加速。

5、压缩CSS、JavaScript和HTML文件  
通过删除所有不必要的空格和注释，从而减小文件大小，提高页面的加载速度。下面是一些优化CSS、JavaScript和HTML文件的流行工具，非常有用。  
CSS Minifier  
Avivo  
HTML Compressor

6、避免重定向  
重定向是对网站访问者的一种极大的刺激。就类似你去一个朋友家，却发现你朋友早已经搬到三个街区远的地方了。重定向会消耗额外的时间，降低加载速度。

7、指定字符集  
指定字符集是加速浏览器渲染页面的另一个有用的技巧。下面的代码就能轻松实现：

8、避免错误请求  
当用户在网站上搜索时，收到404或410错误是比较失望的。错误请求会对网站的页面加载速度产生不利影响。因此，建议你无论如何都要避免错误请求。Check My Link 能帮你找出404链接，清除它们，改善用户体验

### 20 jquery实现简单的tab切换
```js
html:

<section>
   <nav id="nav">
     <a class="on">tab1</a>
     <a>tab2</a>
     <a>tab3</a>
     <a>tab4</a>
   </nav>
   <div id="contentBox">
     <div class="box active">内容一</div>
     <div class="box">内容二</div>
     <div class="box">内容三</div>
     <div class="box">内容四</div>
   </div>
</section>

js

$(function(){
  $("#nav a").off("click").on("click",function(){
     var index = $(this).index();
     $(this).addClass("on").siblings().removeClass("on");
     $("#contentBox .box").eq(index).addClass("active").siblings().removeClass("active");
   });
});

```

### 21 http和https的区别，为什么https更安全
**一、HTTP和HTTPS的基本概念**

　　HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

　　HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

　　HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。

**二、HTTP与HTTPS有什么区别？**

　　HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

　　HTTPS和HTTP的区别主要如下：

　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

**三、HTTPS的优点**

　　尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：

　　（1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；

　　（2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。

　　（3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

　　（4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。

**四、HTTPS的缺点**

　　虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：

　　（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；

　　（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；

　　（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。

　   （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。

　　（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。

**五、http切换到HTTPS**

　如果需要将网站从http切换到https到底该如何实现呢？  
  这里需要将页面中所有的链接，例如js，css，图片等等链接都由http改为https。例如：http://www.baidu.com改为https://www.baidu.com

　　BTW，这里虽然将http切换为了https，还是建议保留http。所以我们在切换的时候可以做http和https的兼容，具体实现方式是，去掉页面链接中的http头部，这样可以自动匹配http头和https头。例如：将 http://www.baidu.com 改为  //www.baidu.com。  然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。

### 13 如何实现浏览器内多个标签的通信
本题主要考察数据存储的知识，数据存储有本地和服务器存储两种方式。这里主要讲解用本地存储方式解决。即调用 localStorage、Cookie等本地存储方式。

> 第一种——调用localStorage

  在一个标签页里面使用 localStorage.setItem(key,value)添加（修改、删除）内容；  
  在另一个标签页里面监听 storage 事件。   
  即可得到 localstorge 存储的值，实现不同标签页之间的通信。  
```js
//标签页1：

<input id="name">  
<input type="button" id="btn" value="提交">  
<script type="text/javascript">  
    $(function(){    
        $("#btn").click(function(){    
            var name=$("#name").val();    
            localStorage.setItem("name", name);   
        });    
    });    
</script>  

//标签页2：

<script type="text/javascript">  
    $(function(){   
        window.addEventListener("storage", function(event){    
            console.log(event.key + "=" + event.newValue);    
        });     
    });  
</script>  

```
> 第二种——调用cookie+setInterval()

将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息。

```js
页面1：

<input id="name">  
<input type="button" id="btn" value="提交">  
<script type="text/javascript">  
    $(function(){    
        $("#btn").click(function(){    
            var name=$("#name").val();    
            document.cookie="name="+name;    
        });    
    });    
</script>  


<script type="text/javascript">  
    $(function(){   
        function getCookie(key) {    
            return JSON.parse("{\"" + document.cookie.replace(/;\s+/gim,"\",\"").replace(/=/gim, "\":\"") + "\"}")[key];    
        }     
        setInterval(function(){    
            console.log("name=" + getCookie("name"));    
        }, 10000);    
    });  
</script>  
```
